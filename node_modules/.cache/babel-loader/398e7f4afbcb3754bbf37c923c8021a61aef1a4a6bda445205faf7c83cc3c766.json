{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Loader, RGBAFormat, RGBA_ASTC_4x4_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, FileLoader, UnsignedByteType, CompressedTexture, LinearFilter, LinearMipmapLinearFilter, FloatType, HalfFloatType, DataTexture, RGFormat, RedFormat } from \"three\";\nimport { WorkerPool } from \"../utils/WorkerPool.js\";\nimport { KHR_DF_TRANSFER_SRGB, KHR_DF_FLAG_ALPHA_PREMULTIPLIED, read, VK_FORMAT_UNDEFINED, KHR_SUPERCOMPRESSION_NONE, KHR_SUPERCOMPRESSION_ZSTD, VK_FORMAT_R32G32B32A32_SFLOAT, VK_FORMAT_R16G16B16A16_SFLOAT, VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_R8G8B8A8_SRGB, VK_FORMAT_R32G32_SFLOAT, VK_FORMAT_R16G16_SFLOAT, VK_FORMAT_R8G8_UNORM, VK_FORMAT_R8G8_SRGB, VK_FORMAT_R32_SFLOAT, VK_FORMAT_R16_SFLOAT, VK_FORMAT_R8_SRGB, VK_FORMAT_R8_UNORM } from \"../libs/ktx-parse.js\";\nimport { ZSTDDecoder } from \"../libs/zstddec.js\";\nimport { CompressedArrayTexture } from \"../_polyfill/CompressedArrayTexture.js\";\nimport { Data3DTexture } from \"../_polyfill/Data3DTexture.js\";\nconst _taskCache = /* @__PURE__ */new WeakMap();\nlet _activeLoaders = 0;\nlet _zstd;\nconst _KTX2Loader = class extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.transcoderPath = \"\";\n    this.transcoderBinary = null;\n    this.transcoderPending = null;\n    this.workerPool = new WorkerPool();\n    this.workerSourceURL = \"\";\n    this.workerConfig = null;\n    if (typeof MSC_TRANSCODER !== \"undefined\") {\n      console.warn('THREE.KTX2Loader: Please update to latest \"basis_transcoder\". \"msc_basis_transcoder\" is no longer supported in three.js r125+.');\n    }\n  }\n  setTranscoderPath(path) {\n    this.transcoderPath = path;\n    return this;\n  }\n  setWorkerLimit(num) {\n    this.workerPool.setWorkerLimit(num);\n    return this;\n  }\n  detectSupport(renderer) {\n    this.workerConfig = {\n      astcSupported: renderer.extensions.has(\"WEBGL_compressed_texture_astc\"),\n      etc1Supported: renderer.extensions.has(\"WEBGL_compressed_texture_etc1\"),\n      etc2Supported: renderer.extensions.has(\"WEBGL_compressed_texture_etc\"),\n      dxtSupported: renderer.extensions.has(\"WEBGL_compressed_texture_s3tc\"),\n      bptcSupported: renderer.extensions.has(\"EXT_texture_compression_bptc\"),\n      pvrtcSupported: renderer.extensions.has(\"WEBGL_compressed_texture_pvrtc\") || renderer.extensions.has(\"WEBKIT_WEBGL_compressed_texture_pvrtc\")\n    };\n    if (renderer.capabilities.isWebGL2) {\n      this.workerConfig.etc1Supported = false;\n    }\n    return this;\n  }\n  init() {\n    if (!this.transcoderPending) {\n      const jsLoader = new FileLoader(this.manager);\n      jsLoader.setPath(this.transcoderPath);\n      jsLoader.setWithCredentials(this.withCredentials);\n      const jsContent = jsLoader.loadAsync(\"basis_transcoder.js\");\n      const binaryLoader = new FileLoader(this.manager);\n      binaryLoader.setPath(this.transcoderPath);\n      binaryLoader.setResponseType(\"arraybuffer\");\n      binaryLoader.setWithCredentials(this.withCredentials);\n      const binaryContent = binaryLoader.loadAsync(\"basis_transcoder.wasm\");\n      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(_ref => {\n        let [jsContent2, binaryContent2] = _ref;\n        const fn = _KTX2Loader.BasisWorker.toString();\n        const body = [\"/* constants */\", \"let _EngineFormat = \" + JSON.stringify(_KTX2Loader.EngineFormat), \"let _TranscoderFormat = \" + JSON.stringify(_KTX2Loader.TranscoderFormat), \"let _BasisFormat = \" + JSON.stringify(_KTX2Loader.BasisFormat), \"/* basis_transcoder.js */\", jsContent2, \"/* worker */\", fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))].join(\"\\n\");\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n        this.transcoderBinary = binaryContent2;\n        this.workerPool.setWorkerCreator(() => {\n          const worker = new Worker(this.workerSourceURL);\n          const transcoderBinary = this.transcoderBinary.slice(0);\n          worker.postMessage({\n            type: \"init\",\n            config: this.workerConfig,\n            transcoderBinary\n          }, [transcoderBinary]);\n          return worker;\n        });\n      });\n      if (_activeLoaders > 0) {\n        console.warn(\"THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances.\");\n      }\n      _activeLoaders++;\n    }\n    return this.transcoderPending;\n  }\n  load(url, onLoad, onProgress, onError) {\n    if (this.workerConfig === null) {\n      throw new Error(\"THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.\");\n    }\n    const loader = new FileLoader(this.manager);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, buffer => {\n      if (_taskCache.has(buffer)) {\n        const cachedTask = _taskCache.get(buffer);\n        return cachedTask.promise.then(onLoad).catch(onError);\n      }\n      this._createTexture(buffer).then(texture => onLoad ? onLoad(texture) : null).catch(onError);\n    }, onProgress, onError);\n  }\n  _createTextureFrom(transcodeResult, container) {\n    const {\n      mipmaps,\n      width,\n      height,\n      format,\n      type,\n      error,\n      dfdTransferFn,\n      dfdFlags\n    } = transcodeResult;\n    if (type === \"error\") return Promise.reject(error);\n    const texture = container.layerCount > 1 ? new CompressedArrayTexture(mipmaps, width, height, container.layerCount, format, UnsignedByteType) : new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);\n    texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;\n    texture.magFilter = LinearFilter;\n    texture.generateMipmaps = false;\n    texture.needsUpdate = true;\n    if (\"colorSpace\" in texture) texture.colorSpace = dfdTransferFn === KHR_DF_TRANSFER_SRGB ? \"srgb\" : \"srgb-linear\";else texture.encoding = dfdTransferFn === KHR_DF_TRANSFER_SRGB ? 3001 : 3e3;\n    texture.premultiplyAlpha = !!(dfdFlags & KHR_DF_FLAG_ALPHA_PREMULTIPLIED);\n    return texture;\n  }\n  /**\n   * @param {ArrayBuffer} buffer\n   * @param {object?} config\n   * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}\n   */\n  async _createTexture(buffer) {\n    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const container = read(new Uint8Array(buffer));\n    if (container.vkFormat !== VK_FORMAT_UNDEFINED) {\n      return createDataTexture(container);\n    }\n    const taskConfig = config;\n    const texturePending = this.init().then(() => {\n      return this.workerPool.postMessage({\n        type: \"transcode\",\n        buffer,\n        taskConfig\n      }, [buffer]);\n    }).then(e => this._createTextureFrom(e.data, container));\n    _taskCache.set(buffer, {\n      promise: texturePending\n    });\n    return texturePending;\n  }\n  dispose() {\n    this.workerPool.dispose();\n    if (this.workerSourceURL) URL.revokeObjectURL(this.workerSourceURL);\n    _activeLoaders--;\n    return this;\n  }\n};\nlet KTX2Loader = _KTX2Loader;\n/* CONSTANTS */\n__publicField(KTX2Loader, \"BasisFormat\", {\n  ETC1S: 0,\n  UASTC_4x4: 1\n});\n__publicField(KTX2Loader, \"TranscoderFormat\", {\n  ETC1: 0,\n  ETC2: 1,\n  BC1: 2,\n  BC3: 3,\n  BC4: 4,\n  BC5: 5,\n  BC7_M6_OPAQUE_ONLY: 6,\n  BC7_M5: 7,\n  PVRTC1_4_RGB: 8,\n  PVRTC1_4_RGBA: 9,\n  ASTC_4x4: 10,\n  ATC_RGB: 11,\n  ATC_RGBA_INTERPOLATED_ALPHA: 12,\n  RGBA32: 13,\n  RGB565: 14,\n  BGR565: 15,\n  RGBA4444: 16\n});\n__publicField(KTX2Loader, \"EngineFormat\", {\n  RGBAFormat,\n  RGBA_ASTC_4x4_Format,\n  RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format,\n  RGB_ETC1_Format,\n  RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format\n});\n/* WEB WORKER */\n__publicField(KTX2Loader, \"BasisWorker\", function () {\n  let config;\n  let transcoderPending;\n  let BasisModule;\n  const EngineFormat = _EngineFormat;\n  const TranscoderFormat = _TranscoderFormat;\n  const BasisFormat = _BasisFormat;\n  self.addEventListener(\"message\", function (e) {\n    const message = e.data;\n    switch (message.type) {\n      case \"init\":\n        config = message.config;\n        init(message.transcoderBinary);\n        break;\n      case \"transcode\":\n        transcoderPending.then(() => {\n          try {\n            const {\n              width,\n              height,\n              hasAlpha,\n              mipmaps,\n              format,\n              dfdTransferFn,\n              dfdFlags\n            } = transcode(message.buffer);\n            const buffers = [];\n            for (let i = 0; i < mipmaps.length; ++i) {\n              buffers.push(mipmaps[i].data.buffer);\n            }\n            self.postMessage({\n              type: \"transcode\",\n              id: message.id,\n              width,\n              height,\n              hasAlpha,\n              mipmaps,\n              format,\n              dfdTransferFn,\n              dfdFlags\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: \"error\",\n              id: message.id,\n              error: error.message\n            });\n          }\n        });\n        break;\n    }\n  });\n  function init(wasmBinary) {\n    transcoderPending = new Promise(resolve => {\n      BasisModule = {\n        wasmBinary,\n        onRuntimeInitialized: resolve\n      };\n      BASIS(BasisModule);\n    }).then(() => {\n      BasisModule.initializeBasis();\n      if (BasisModule.KTX2File === void 0) {\n        console.warn(\"THREE.KTX2Loader: Please update Basis Universal transcoder.\");\n      }\n    });\n  }\n  function transcode(buffer) {\n    const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));\n    function cleanup() {\n      ktx2File.close();\n      ktx2File.delete();\n    }\n    if (!ktx2File.isValid()) {\n      cleanup();\n      throw new Error(\"THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file\");\n    }\n    const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;\n    const width = ktx2File.getWidth();\n    const height = ktx2File.getHeight();\n    const layers = ktx2File.getLayers() || 1;\n    const levels = ktx2File.getLevels();\n    const hasAlpha = ktx2File.getHasAlpha();\n    const dfdTransferFn = ktx2File.getDFDTransferFunc();\n    const dfdFlags = ktx2File.getDFDFlags();\n    const {\n      transcoderFormat,\n      engineFormat\n    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\n    if (!width || !height || !levels) {\n      cleanup();\n      throw new Error(\"THREE.KTX2Loader:\tInvalid texture\");\n    }\n    if (!ktx2File.startTranscoding()) {\n      cleanup();\n      throw new Error(\"THREE.KTX2Loader: .startTranscoding failed\");\n    }\n    const mipmaps = [];\n    for (let mip = 0; mip < levels; mip++) {\n      const layerMips = [];\n      let mipWidth, mipHeight;\n      for (let layer = 0; layer < layers; layer++) {\n        const levelInfo = ktx2File.getImageLevelInfo(mip, layer, 0);\n        mipWidth = levelInfo.origWidth < 4 ? levelInfo.origWidth : levelInfo.width;\n        mipHeight = levelInfo.origHeight < 4 ? levelInfo.origHeight : levelInfo.height;\n        const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, transcoderFormat));\n        const status = ktx2File.transcodeImage(dst, mip, layer, 0, transcoderFormat, 0, -1, -1);\n        if (!status) {\n          cleanup();\n          throw new Error(\"THREE.KTX2Loader: .transcodeImage failed.\");\n        }\n        layerMips.push(dst);\n      }\n      mipmaps.push({\n        data: concat(layerMips),\n        width: mipWidth,\n        height: mipHeight\n      });\n    }\n    cleanup();\n    return {\n      width,\n      height,\n      hasAlpha,\n      mipmaps,\n      format: engineFormat,\n      dfdTransferFn,\n      dfdFlags\n    };\n  }\n  const FORMAT_OPTIONS = [{\n    if: \"astcSupported\",\n    basisFormat: [BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n    engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n    priorityETC1S: Infinity,\n    priorityUASTC: 1,\n    needsPowerOfTwo: false\n  }, {\n    if: \"bptcSupported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n    engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n    priorityETC1S: 3,\n    priorityUASTC: 2,\n    needsPowerOfTwo: false\n  }, {\n    if: \"dxtSupported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n    engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n    priorityETC1S: 4,\n    priorityUASTC: 5,\n    needsPowerOfTwo: false\n  }, {\n    if: \"etc2Supported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n    engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n    priorityETC1S: 1,\n    priorityUASTC: 3,\n    needsPowerOfTwo: false\n  }, {\n    if: \"etc1Supported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1],\n    engineFormat: [EngineFormat.RGB_ETC1_Format],\n    priorityETC1S: 2,\n    priorityUASTC: 4,\n    needsPowerOfTwo: false\n  }, {\n    if: \"pvrtcSupported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n    engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n    priorityETC1S: 5,\n    priorityUASTC: 6,\n    needsPowerOfTwo: true\n  }];\n  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityETC1S - b.priorityETC1S;\n  });\n  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityUASTC - b.priorityUASTC;\n  });\n  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n    let transcoderFormat;\n    let engineFormat;\n    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;\n    for (let i = 0; i < options.length; i++) {\n      const opt = options[i];\n      if (!config[opt.if]) continue;\n      if (!opt.basisFormat.includes(basisFormat)) continue;\n      if (hasAlpha && opt.transcoderFormat.length < 2) continue;\n      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;\n      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];\n      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];\n      return {\n        transcoderFormat,\n        engineFormat\n      };\n    }\n    console.warn(\"THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.\");\n    transcoderFormat = TranscoderFormat.RGBA32;\n    engineFormat = EngineFormat.RGBAFormat;\n    return {\n      transcoderFormat,\n      engineFormat\n    };\n  }\n  function isPowerOfTwo(value) {\n    if (value <= 2) return true;\n    return (value & value - 1) === 0 && value !== 0;\n  }\n  function concat(arrays) {\n    let totalByteLength = 0;\n    for (let i = 0; i < arrays.length; i++) {\n      const array = arrays[i];\n      totalByteLength += array.byteLength;\n    }\n    const result = new Uint8Array(totalByteLength);\n    let byteOffset = 0;\n    for (let i = 0; i < arrays.length; i++) {\n      const array = arrays[i];\n      result.set(array, byteOffset);\n      byteOffset += array.byteLength;\n    }\n    return result;\n  }\n});\nconst FORMAT_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_UNORM]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_SRGB]: RGBAFormat,\n  [VK_FORMAT_R32G32_SFLOAT]: RGFormat,\n  [VK_FORMAT_R16G16_SFLOAT]: RGFormat,\n  [VK_FORMAT_R8G8_UNORM]: RGFormat,\n  [VK_FORMAT_R8G8_SRGB]: RGFormat,\n  [VK_FORMAT_R32_SFLOAT]: RedFormat,\n  [VK_FORMAT_R16_SFLOAT]: RedFormat,\n  [VK_FORMAT_R8_SRGB]: RedFormat,\n  [VK_FORMAT_R8_UNORM]: RedFormat\n};\nconst TYPE_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8B8A8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8B8A8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R32G32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R8_UNORM]: UnsignedByteType\n};\nconst ENCODING_MAP = {\n  [VK_FORMAT_R8G8B8A8_SRGB]: 3001,\n  // sRGBEncoding\n  [VK_FORMAT_R8G8_SRGB]: 3001,\n  // sRGBEncoding\n  [VK_FORMAT_R8_SRGB]: 3001\n  // sRGBEncoding\n};\n\nasync function createDataTexture(container) {\n  const {\n    vkFormat,\n    pixelWidth,\n    pixelHeight,\n    pixelDepth\n  } = container;\n  if (FORMAT_MAP[vkFormat] === void 0) {\n    throw new Error(\"THREE.KTX2Loader: Unsupported vkFormat.\");\n  }\n  const level = container.levels[0];\n  let levelData;\n  let view;\n  if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_NONE) {\n    levelData = level.levelData;\n  } else if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {\n    if (!_zstd) {\n      _zstd = new Promise(async resolve => {\n        const zstd = new ZSTDDecoder();\n        await zstd.init();\n        resolve(zstd);\n      });\n    }\n    levelData = (await _zstd).decode(level.levelData, level.uncompressedByteLength);\n  } else {\n    throw new Error(\"THREE.KTX2Loader: Unsupported supercompressionScheme.\");\n  }\n  if (TYPE_MAP[vkFormat] === FloatType) {\n    view = new Float32Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Float32Array.BYTES_PER_ELEMENT);\n  } else if (TYPE_MAP[vkFormat] === HalfFloatType) {\n    view = new Uint16Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT);\n  } else {\n    view = levelData;\n  }\n  const texture = pixelDepth === 0 ? new DataTexture(view, pixelWidth, pixelHeight) : new Data3DTexture(view, pixelWidth, pixelHeight, pixelDepth);\n  texture.type = TYPE_MAP[vkFormat];\n  texture.format = FORMAT_MAP[vkFormat];\n  texture.encoding = ENCODING_MAP[vkFormat] || 3e3;\n  texture.needsUpdate = true;\n  return Promise.resolve(texture);\n}\nexport { KTX2Loader };","map":{"version":3,"names":["_taskCache","WeakMap","_activeLoaders","_zstd","_KTX2Loader","Loader","constructor","manager","transcoderPath","transcoderBinary","transcoderPending","workerPool","WorkerPool","workerSourceURL","workerConfig","MSC_TRANSCODER","console","warn","setTranscoderPath","path","setWorkerLimit","num","detectSupport","renderer","astcSupported","extensions","has","etc1Supported","etc2Supported","dxtSupported","bptcSupported","pvrtcSupported","capabilities","isWebGL2","init","jsLoader","FileLoader","setPath","setWithCredentials","withCredentials","jsContent","loadAsync","binaryLoader","setResponseType","binaryContent","Promise","all","then","_ref","jsContent2","binaryContent2","fn","BasisWorker","toString","body","JSON","stringify","EngineFormat","TranscoderFormat","BasisFormat","substring","indexOf","lastIndexOf","join","URL","createObjectURL","Blob","setWorkerCreator","worker","Worker","slice","postMessage","type","config","load","url","onLoad","onProgress","onError","Error","loader","buffer","cachedTask","get","promise","catch","_createTexture","texture","_createTextureFrom","transcodeResult","container","mipmaps","width","height","format","error","dfdTransferFn","dfdFlags","reject","layerCount","CompressedArrayTexture","UnsignedByteType","CompressedTexture","minFilter","length","LinearFilter","LinearMipmapLinearFilter","magFilter","generateMipmaps","needsUpdate","colorSpace","KHR_DF_TRANSFER_SRGB","encoding","premultiplyAlpha","KHR_DF_FLAG_ALPHA_PREMULTIPLIED","arguments","undefined","read","Uint8Array","vkFormat","VK_FORMAT_UNDEFINED","createDataTexture","taskConfig","texturePending","e","data","set","dispose","revokeObjectURL","KTX2Loader","__publicField","ETC1S","UASTC_4x4","ETC1","ETC2","BC1","BC3","BC4","BC5","BC7_M6_OPAQUE_ONLY","BC7_M5","PVRTC1_4_RGB","PVRTC1_4_RGBA","ASTC_4x4","ATC_RGB","ATC_RGBA_INTERPOLATED_ALPHA","RGBA32","RGB565","BGR565","RGBA4444","RGBAFormat","RGBA_ASTC_4x4_Format","RGBA_BPTC_Format","RGBA_ETC2_EAC_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_S3TC_DXT5_Format","RGB_ETC1_Format","RGB_ETC2_Format","RGB_PVRTC_4BPPV1_Format","RGB_S3TC_DXT1_Format","BasisModule","_EngineFormat","_TranscoderFormat","_BasisFormat","self","addEventListener","message","hasAlpha","transcode","buffers","i","push","id","wasmBinary","resolve","onRuntimeInitialized","BASIS","initializeBasis","KTX2File","ktx2File","cleanup","close","delete","isValid","basisFormat","isUASTC","getWidth","getHeight","layers","getLayers","levels","getLevels","getHasAlpha","getDFDTransferFunc","getDFDFlags","transcoderFormat","engineFormat","getTranscoderFormat","startTranscoding","mip","layerMips","mipWidth","mipHeight","layer","levelInfo","getImageLevelInfo","origWidth","origHeight","dst","getImageTranscodedSizeInBytes","status","transcodeImage","concat","FORMAT_OPTIONS","if","priorityETC1S","Infinity","priorityUASTC","needsPowerOfTwo","ETC1S_OPTIONS","sort","a","b","UASTC_OPTIONS","options","opt","includes","isPowerOfTwo","value","arrays","totalByteLength","array","byteLength","result","byteOffset","FORMAT_MAP","VK_FORMAT_R32G32B32A32_SFLOAT","VK_FORMAT_R16G16B16A16_SFLOAT","VK_FORMAT_R8G8B8A8_UNORM","VK_FORMAT_R8G8B8A8_SRGB","VK_FORMAT_R32G32_SFLOAT","RGFormat","VK_FORMAT_R16G16_SFLOAT","VK_FORMAT_R8G8_UNORM","VK_FORMAT_R8G8_SRGB","VK_FORMAT_R32_SFLOAT","RedFormat","VK_FORMAT_R16_SFLOAT","VK_FORMAT_R8_SRGB","VK_FORMAT_R8_UNORM","TYPE_MAP","FloatType","HalfFloatType","ENCODING_MAP","pixelWidth","pixelHeight","pixelDepth","level","levelData","view","supercompressionScheme","KHR_SUPERCOMPRESSION_NONE","KHR_SUPERCOMPRESSION_ZSTD","zstd","ZSTDDecoder","decode","uncompressedByteLength","Float32Array","BYTES_PER_ELEMENT","Uint16Array","DataTexture","Data3DTexture"],"sources":["/home/precious/Desktop/threefibrejs/node_modules/src/loaders/KTX2Loader.js"],"sourcesContent":["/**\n * Loader for KTX 2.0 GPU Texture containers.\n *\n * KTX 2.0 is a container format for various GPU texture formats. The loader\n * supports Basis Universal GPU textures, which can be quickly transcoded to\n * a wide variety of GPU texture compression formats, as well as some\n * uncompressed DataTexture and Data3DTexture formats.\n *\n * References:\n * - KTX: http://github.khronos.org/KTX-Specification/\n * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor\n */\n\nimport {\n  CompressedTexture,\n  DataTexture,\n  FileLoader,\n  FloatType,\n  HalfFloatType,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  Loader,\n  RedFormat,\n  RGB_ETC1_Format,\n  RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format,\n  RGBA_ASTC_4x4_Format,\n  RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format,\n  RGBAFormat,\n  RGFormat,\n  UnsignedByteType,\n} from 'three'\nimport { WorkerPool } from '../utils/WorkerPool'\nimport {\n  read,\n  KHR_DF_FLAG_ALPHA_PREMULTIPLIED,\n  KHR_DF_TRANSFER_SRGB,\n  KHR_SUPERCOMPRESSION_NONE,\n  KHR_SUPERCOMPRESSION_ZSTD,\n  VK_FORMAT_UNDEFINED,\n  VK_FORMAT_R16_SFLOAT,\n  VK_FORMAT_R16G16_SFLOAT,\n  VK_FORMAT_R16G16B16A16_SFLOAT,\n  VK_FORMAT_R32_SFLOAT,\n  VK_FORMAT_R32G32_SFLOAT,\n  VK_FORMAT_R32G32B32A32_SFLOAT,\n  VK_FORMAT_R8_SRGB,\n  VK_FORMAT_R8_UNORM,\n  VK_FORMAT_R8G8_SRGB,\n  VK_FORMAT_R8G8_UNORM,\n  VK_FORMAT_R8G8B8A8_SRGB,\n  VK_FORMAT_R8G8B8A8_UNORM,\n} from '../libs/ktx-parse'\nimport { ZSTDDecoder } from '../libs/zstddec'\nimport { CompressedArrayTexture } from '../_polyfill/CompressedArrayTexture'\nimport { Data3DTexture } from '../_polyfill/Data3DTexture'\n\nconst _taskCache = new WeakMap()\n\nlet _activeLoaders = 0\n\nlet _zstd\n\nclass KTX2Loader extends Loader {\n  /* CONSTANTS */\n\n  static BasisFormat = {\n    ETC1S: 0,\n    UASTC_4x4: 1,\n  }\n\n  static TranscoderFormat = {\n    ETC1: 0,\n    ETC2: 1,\n    BC1: 2,\n    BC3: 3,\n    BC4: 4,\n    BC5: 5,\n    BC7_M6_OPAQUE_ONLY: 6,\n    BC7_M5: 7,\n    PVRTC1_4_RGB: 8,\n    PVRTC1_4_RGBA: 9,\n    ASTC_4x4: 10,\n    ATC_RGB: 11,\n    ATC_RGBA_INTERPOLATED_ALPHA: 12,\n    RGBA32: 13,\n    RGB565: 14,\n    BGR565: 15,\n    RGBA4444: 16,\n  }\n\n  static EngineFormat = {\n    RGBAFormat: RGBAFormat,\n    RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\n    RGBA_BPTC_Format: RGBA_BPTC_Format,\n    RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,\n    RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\n    RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\n    RGB_ETC1_Format: RGB_ETC1_Format,\n    RGB_ETC2_Format: RGB_ETC2_Format,\n    RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\n    RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format,\n  }\n\n  /* WEB WORKER */\n\n  static BasisWorker = function () {\n    let config\n    let transcoderPending\n    let BasisModule\n\n    const EngineFormat = _EngineFormat\n    const TranscoderFormat = _TranscoderFormat\n    const BasisFormat = _BasisFormat\n\n    self.addEventListener('message', function (e) {\n      const message = e.data\n\n      switch (message.type) {\n        case 'init':\n          config = message.config\n          init(message.transcoderBinary)\n          break\n\n        case 'transcode':\n          transcoderPending.then(() => {\n            try {\n              const { width, height, hasAlpha, mipmaps, format, dfdTransferFn, dfdFlags } = transcode(message.buffer)\n\n              const buffers = []\n\n              for (let i = 0; i < mipmaps.length; ++i) {\n                buffers.push(mipmaps[i].data.buffer)\n              }\n\n              self.postMessage(\n                {\n                  type: 'transcode',\n                  id: message.id,\n                  width,\n                  height,\n                  hasAlpha,\n                  mipmaps,\n                  format,\n                  dfdTransferFn,\n                  dfdFlags,\n                },\n                buffers,\n              )\n            } catch (error) {\n              console.error(error)\n\n              self.postMessage({ type: 'error', id: message.id, error: error.message })\n            }\n          })\n          break\n      }\n    })\n\n    function init(wasmBinary) {\n      transcoderPending = new Promise((resolve) => {\n        BasisModule = { wasmBinary, onRuntimeInitialized: resolve }\n        BASIS(BasisModule)\n      }).then(() => {\n        BasisModule.initializeBasis()\n\n        if (BasisModule.KTX2File === undefined) {\n          console.warn('THREE.KTX2Loader: Please update Basis Universal transcoder.')\n        }\n      })\n    }\n\n    function transcode(buffer) {\n      const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer))\n\n      function cleanup() {\n        ktx2File.close()\n        ktx2File.delete()\n      }\n\n      if (!ktx2File.isValid()) {\n        cleanup()\n        throw new Error('THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file')\n      }\n\n      const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S\n      const width = ktx2File.getWidth()\n      const height = ktx2File.getHeight()\n      const layers = ktx2File.getLayers() || 1\n      const levels = ktx2File.getLevels()\n      const hasAlpha = ktx2File.getHasAlpha()\n      const dfdTransferFn = ktx2File.getDFDTransferFunc()\n      const dfdFlags = ktx2File.getDFDFlags()\n\n      const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha)\n\n      if (!width || !height || !levels) {\n        cleanup()\n        throw new Error('THREE.KTX2Loader:\tInvalid texture')\n      }\n\n      if (!ktx2File.startTranscoding()) {\n        cleanup()\n        throw new Error('THREE.KTX2Loader: .startTranscoding failed')\n      }\n\n      const mipmaps = []\n\n      for (let mip = 0; mip < levels; mip++) {\n        const layerMips = []\n\n        let mipWidth, mipHeight\n\n        for (let layer = 0; layer < layers; layer++) {\n          const levelInfo = ktx2File.getImageLevelInfo(mip, layer, 0)\n          mipWidth = levelInfo.origWidth < 4 ? levelInfo.origWidth : levelInfo.width\n          mipHeight = levelInfo.origHeight < 4 ? levelInfo.origHeight : levelInfo.height\n          const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, transcoderFormat))\n          const status = ktx2File.transcodeImage(dst, mip, layer, 0, transcoderFormat, 0, -1, -1)\n\n          if (!status) {\n            cleanup()\n            throw new Error('THREE.KTX2Loader: .transcodeImage failed.')\n          }\n\n          layerMips.push(dst)\n        }\n\n        mipmaps.push({ data: concat(layerMips), width: mipWidth, height: mipHeight })\n      }\n\n      cleanup()\n\n      return { width, height, hasAlpha, mipmaps, format: engineFormat, dfdTransferFn, dfdFlags }\n    }\n\n    //\n\n    // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),\n    // device capabilities, and texture dimensions. The list below ranks the formats separately\n    // for ETC1S and UASTC.\n    //\n    // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at\n    // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently\n    // chooses RGBA32 only as a last resort and does not expose that option to the caller.\n    const FORMAT_OPTIONS = [\n      {\n        if: 'astcSupported',\n        basisFormat: [BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n        engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n        priorityETC1S: Infinity,\n        priorityUASTC: 1,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'bptcSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n        engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n        priorityETC1S: 3,\n        priorityUASTC: 2,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'dxtSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n        engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n        priorityETC1S: 4,\n        priorityUASTC: 5,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'etc2Supported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n        engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n        priorityETC1S: 1,\n        priorityUASTC: 3,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'etc1Supported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ETC1],\n        engineFormat: [EngineFormat.RGB_ETC1_Format],\n        priorityETC1S: 2,\n        priorityUASTC: 4,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'pvrtcSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n        engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n        priorityETC1S: 5,\n        priorityUASTC: 6,\n        needsPowerOfTwo: true,\n      },\n    ]\n\n    const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n      return a.priorityETC1S - b.priorityETC1S\n    })\n    const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n      return a.priorityUASTC - b.priorityUASTC\n    })\n\n    function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n      let transcoderFormat\n      let engineFormat\n\n      const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS\n\n      for (let i = 0; i < options.length; i++) {\n        const opt = options[i]\n\n        if (!config[opt.if]) continue\n        if (!opt.basisFormat.includes(basisFormat)) continue\n        if (hasAlpha && opt.transcoderFormat.length < 2) continue\n        if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue\n\n        transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0]\n        engineFormat = opt.engineFormat[hasAlpha ? 1 : 0]\n\n        return { transcoderFormat, engineFormat }\n      }\n\n      console.warn('THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.')\n\n      transcoderFormat = TranscoderFormat.RGBA32\n      engineFormat = EngineFormat.RGBAFormat\n\n      return { transcoderFormat, engineFormat }\n    }\n\n    function isPowerOfTwo(value) {\n      if (value <= 2) return true\n\n      return (value & (value - 1)) === 0 && value !== 0\n    }\n\n    /** Concatenates N byte arrays. */\n    function concat(arrays) {\n      let totalByteLength = 0\n\n      for (let i = 0; i < arrays.length; i++) {\n        const array = arrays[i]\n        totalByteLength += array.byteLength\n      }\n\n      const result = new Uint8Array(totalByteLength)\n\n      let byteOffset = 0\n\n      for (let i = 0; i < arrays.length; i++) {\n        const array = arrays[i]\n        result.set(array, byteOffset)\n\n        byteOffset += array.byteLength\n      }\n\n      return result\n    }\n  }\n\n  constructor(manager) {\n    super(manager)\n\n    this.transcoderPath = ''\n    this.transcoderBinary = null\n    this.transcoderPending = null\n\n    this.workerPool = new WorkerPool()\n    this.workerSourceURL = ''\n    this.workerConfig = null\n\n    if (typeof MSC_TRANSCODER !== 'undefined') {\n      console.warn(\n        'THREE.KTX2Loader: Please update to latest \"basis_transcoder\".' +\n          ' \"msc_basis_transcoder\" is no longer supported in three.js r125+.',\n      )\n    }\n  }\n\n  setTranscoderPath(path) {\n    this.transcoderPath = path\n\n    return this\n  }\n\n  setWorkerLimit(num) {\n    this.workerPool.setWorkerLimit(num)\n\n    return this\n  }\n\n  detectSupport(renderer) {\n    this.workerConfig = {\n      astcSupported: renderer.extensions.has('WEBGL_compressed_texture_astc'),\n      etc1Supported: renderer.extensions.has('WEBGL_compressed_texture_etc1'),\n      etc2Supported: renderer.extensions.has('WEBGL_compressed_texture_etc'),\n      dxtSupported: renderer.extensions.has('WEBGL_compressed_texture_s3tc'),\n      bptcSupported: renderer.extensions.has('EXT_texture_compression_bptc'),\n      pvrtcSupported:\n        renderer.extensions.has('WEBGL_compressed_texture_pvrtc') ||\n        renderer.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n    }\n\n    if (renderer.capabilities.isWebGL2) {\n      // https://github.com/mrdoob/three.js/pull/22928\n      this.workerConfig.etc1Supported = false\n    }\n\n    return this\n  }\n\n  init() {\n    if (!this.transcoderPending) {\n      // Load transcoder wrapper.\n      const jsLoader = new FileLoader(this.manager)\n      jsLoader.setPath(this.transcoderPath)\n      jsLoader.setWithCredentials(this.withCredentials)\n      const jsContent = jsLoader.loadAsync('basis_transcoder.js')\n\n      // Load transcoder WASM binary.\n      const binaryLoader = new FileLoader(this.manager)\n      binaryLoader.setPath(this.transcoderPath)\n      binaryLoader.setResponseType('arraybuffer')\n      binaryLoader.setWithCredentials(this.withCredentials)\n      const binaryContent = binaryLoader.loadAsync('basis_transcoder.wasm')\n\n      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent, binaryContent]) => {\n        const fn = KTX2Loader.BasisWorker.toString()\n\n        const body = [\n          '/* constants */',\n          'let _EngineFormat = ' + JSON.stringify(KTX2Loader.EngineFormat),\n          'let _TranscoderFormat = ' + JSON.stringify(KTX2Loader.TranscoderFormat),\n          'let _BasisFormat = ' + JSON.stringify(KTX2Loader.BasisFormat),\n          '/* basis_transcoder.js */',\n          jsContent,\n          '/* worker */',\n          fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n        ].join('\\n')\n\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n        this.transcoderBinary = binaryContent\n\n        this.workerPool.setWorkerCreator(() => {\n          const worker = new Worker(this.workerSourceURL)\n          const transcoderBinary = this.transcoderBinary.slice(0)\n\n          worker.postMessage({ type: 'init', config: this.workerConfig, transcoderBinary }, [transcoderBinary])\n\n          return worker\n        })\n      })\n\n      if (_activeLoaders > 0) {\n        // Each instance loads a transcoder and allocates workers, increasing network and memory cost.\n\n        console.warn(\n          'THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues.' +\n            ' Use a single KTX2Loader instance, or call .dispose() on old instances.',\n        )\n      }\n\n      _activeLoaders++\n    }\n\n    return this.transcoderPending\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    if (this.workerConfig === null) {\n      throw new Error('THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.')\n    }\n\n    const loader = new FileLoader(this.manager)\n\n    loader.setResponseType('arraybuffer')\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      (buffer) => {\n        // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n        // again from this thread.\n        if (_taskCache.has(buffer)) {\n          const cachedTask = _taskCache.get(buffer)\n\n          return cachedTask.promise.then(onLoad).catch(onError)\n        }\n\n        this._createTexture(buffer)\n          .then((texture) => (onLoad ? onLoad(texture) : null))\n          .catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  _createTextureFrom(transcodeResult, container) {\n    const { mipmaps, width, height, format, type, error, dfdTransferFn, dfdFlags } = transcodeResult\n\n    if (type === 'error') return Promise.reject(error)\n\n    const texture =\n      container.layerCount > 1\n        ? new CompressedArrayTexture(mipmaps, width, height, container.layerCount, format, UnsignedByteType)\n        : new CompressedTexture(mipmaps, width, height, format, UnsignedByteType)\n\n    texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter\n    texture.magFilter = LinearFilter\n    texture.generateMipmaps = false\n    texture.needsUpdate = true\n    if ('colorSpace' in texture) texture.colorSpace = dfdTransferFn === KHR_DF_TRANSFER_SRGB ? 'srgb' : 'srgb-linear'\n    else texture.encoding = dfdTransferFn === KHR_DF_TRANSFER_SRGB ? 3001 : 3000\n    texture.premultiplyAlpha = !!(dfdFlags & KHR_DF_FLAG_ALPHA_PREMULTIPLIED)\n\n    return texture\n  }\n\n  /**\n   * @param {ArrayBuffer} buffer\n   * @param {object?} config\n   * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}\n   */\n  async _createTexture(buffer, config = {}) {\n    const container = read(new Uint8Array(buffer))\n\n    if (container.vkFormat !== VK_FORMAT_UNDEFINED) {\n      return createDataTexture(container)\n    }\n\n    //\n\n    const taskConfig = config\n    const texturePending = this.init()\n      .then(() => {\n        return this.workerPool.postMessage({ type: 'transcode', buffer, taskConfig: taskConfig }, [buffer])\n      })\n      .then((e) => this._createTextureFrom(e.data, container))\n\n    // Cache the task result.\n    _taskCache.set(buffer, { promise: texturePending })\n\n    return texturePending\n  }\n\n  dispose() {\n    this.workerPool.dispose()\n    if (this.workerSourceURL) URL.revokeObjectURL(this.workerSourceURL)\n\n    _activeLoaders--\n\n    return this\n  }\n}\n\n//\n// DataTexture and Data3DTexture parsing.\n\nconst FORMAT_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_UNORM]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_SRGB]: RGBAFormat,\n\n  [VK_FORMAT_R32G32_SFLOAT]: RGFormat,\n  [VK_FORMAT_R16G16_SFLOAT]: RGFormat,\n  [VK_FORMAT_R8G8_UNORM]: RGFormat,\n  [VK_FORMAT_R8G8_SRGB]: RGFormat,\n\n  [VK_FORMAT_R32_SFLOAT]: RedFormat,\n  [VK_FORMAT_R16_SFLOAT]: RedFormat,\n  [VK_FORMAT_R8_SRGB]: RedFormat,\n  [VK_FORMAT_R8_UNORM]: RedFormat,\n}\n\nconst TYPE_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8B8A8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8B8A8_SRGB]: UnsignedByteType,\n\n  [VK_FORMAT_R32G32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8_SRGB]: UnsignedByteType,\n\n  [VK_FORMAT_R32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R8_UNORM]: UnsignedByteType,\n}\n\nconst ENCODING_MAP = {\n  [VK_FORMAT_R8G8B8A8_SRGB]: 3001, // sRGBEncoding\n  [VK_FORMAT_R8G8_SRGB]: 3001, // sRGBEncoding\n  [VK_FORMAT_R8_SRGB]: 3001, // sRGBEncoding\n}\n\nasync function createDataTexture(container) {\n  const { vkFormat, pixelWidth, pixelHeight, pixelDepth } = container\n\n  if (FORMAT_MAP[vkFormat] === undefined) {\n    throw new Error('THREE.KTX2Loader: Unsupported vkFormat.')\n  }\n\n  //\n\n  const level = container.levels[0]\n\n  let levelData\n  let view\n\n  if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_NONE) {\n    levelData = level.levelData\n  } else if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {\n    if (!_zstd) {\n      _zstd = new Promise(async (resolve) => {\n        const zstd = new ZSTDDecoder()\n        await zstd.init()\n        resolve(zstd)\n      })\n    }\n\n    levelData = (await _zstd).decode(level.levelData, level.uncompressedByteLength)\n  } else {\n    throw new Error('THREE.KTX2Loader: Unsupported supercompressionScheme.')\n  }\n\n  if (TYPE_MAP[vkFormat] === FloatType) {\n    view = new Float32Array(\n      levelData.buffer,\n      levelData.byteOffset,\n      levelData.byteLength / Float32Array.BYTES_PER_ELEMENT,\n    )\n  } else if (TYPE_MAP[vkFormat] === HalfFloatType) {\n    view = new Uint16Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT)\n  } else {\n    view = levelData\n  }\n\n  //\n\n  const texture =\n    pixelDepth === 0\n      ? new DataTexture(view, pixelWidth, pixelHeight)\n      : new Data3DTexture(view, pixelWidth, pixelHeight, pixelDepth)\n\n  texture.type = TYPE_MAP[vkFormat]\n  texture.format = FORMAT_MAP[vkFormat]\n  texture.encoding = ENCODING_MAP[vkFormat] || 3000 // LinearEncoding\n\n  texture.needsUpdate = true\n\n  //\n\n  return Promise.resolve(texture)\n}\n\nexport { KTX2Loader }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}